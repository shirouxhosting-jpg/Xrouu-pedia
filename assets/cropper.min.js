/*!
 * Cropper.js v1.5.13
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 */

// Helper: Merge objects (polyfill Object.assign)
function assign(target, ...sources) {
  sources.forEach(source => {
    if (source && typeof source === 'object') {
      Object.keys(source).forEach(key => {
        target[key] = source[key];
      });
    }
  });
  return target;
}

// Helper: Check if value is number and not NaN
function isNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}

// Helper: Check finite positive number
function isPositiveFinite(value) {
  return value > 0 && value < Infinity;
}

// Helper: Check if value is undefined
function isUndefined(value) {
  return value === undefined;
}

// Helper: Check if value is plain object
function isPlainObject(value) {
  if (value === null || typeof value !== 'object') return false;
  const proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype;
}

// Helper: Check if value is function
function isFunction(value) {
  return typeof value === 'function';
}

// Default options
const DEFAULT_OPTIONS = {
  viewMode: 0,
  dragMode: 'crop',
  initialAspectRatio: NaN,
  aspectRatio: NaN,
  data: null,
  preview: '',
  responsive: true,
  restore: true,
  checkCrossOrigin: true,
  checkOrientation: true,
  modal: true,
  guides: true,
  center: true,
  highlight: true,
  background: true,
  autoCrop: true,
  autoCropArea: 0.8,
  movable: true,
  rotatable: true,
  scalable: true,
  zoomable: true,
  zoomOnTouch: true,
  zoomOnWheel: true,
  wheelZoomRatio: 0.1,
  cropBoxMovable: true,
  cropBoxResizable: true,
  toggleDragModeOnDblclick: true,
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: 200,
  minContainerHeight: 100,
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
};

// Constants
const NAMESPACE = 'cropper';
const ACTION_ALL = 'all';
const ACTION_CROP = 'crop';
const ACTION_MOVE = 'move';
const ACTION_ZOOM = 'zoom';
const ACTION_EAST = 'e';
const ACTION_WEST = 'w';
const ACTION_SOUTH = 's';
const ACTION_NORTH = 'n';
const ACTION_NORTHEAST = 'ne';
const ACTION_NORTHWEST = 'nw';
const ACTION_SOUTHEAST = 'se';
const ACTION_SOUTHWEST = 'sw';

// Class names
const CLASS_CROP = `${NAMESPACE}-crop`;
const CLASS_DISABLED = `${NAMESPACE}-disabled`;
const CLASS_HIDDEN = `${NAMESPACE}-hidden`;
const CLASS_HIDE = `${NAMESPACE}-hide`;
const CLASS_INVISIBLE = `${NAMESPACE}-invisible`;
const CLASS_MODAL = `${NAMESPACE}-modal`;
const CLASS_MOVE = `${NAMESPACE}-move`;
const DATA_ACTION = `${NAMESPACE}Action`;
const DATA_PREVIEW = `${NAMESPACE}Preview`;

// Events
const EVENT_CROP = 'crop';
const EVENT_CROP_END = 'cropend';
const EVENT_CROP_MOVE = 'cropmove';
const EVENT_CROP_START = 'cropstart';
const EVENT_DBLCLICK = 'dblclick';
const EVENT_POINTER_DOWN = 'pointerdown';
const EVENT_POINTER_MOVE = 'pointermove';
const EVENT_POINTER_UP = 'pointerup pointercancel';
const EVENT_ZOOM = 'zoom';

// Main Cropper class
class Cropper {
  constructor(element, options = {}) {
    if (!element || !/img|canvas/i.test(element.tagName)) {
      throw new Error('The first argument is required and must be an <img> or <canvas> element.');
    }

    this.element = element;
    this.options = assign({}, DEFAULT_OPTIONS, options);
    this.cropped = false;
    this.disabled = false;
    this.pointers = {};
    this.ready = false;
    this.reloading = false;
    this.replaced = false;
    this.sized = false;
    this.sizing = false;

    this.init();
  }

  // Initialize the cropper
  init() {
    const { element } = this;
    const tagName = element.tagName.toLowerCase();

    if (element.cropper) return;

    element.cropper = this;

    let url;
    if (tagName === 'img') {
      this.isImg = true;
      url = element.getAttribute('src') || '';
      this.originalUrl = url || '';
      if (!url) return;
    } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
      url = element.toDataURL();
    }

    this.url = url;
    this.load(url);
  }

  // Load image from URL
  load(url) {
    if (!url) return;

    this.url = url;
    this.imageData = {};

    const { options } = this;

    if (options.rotatable || options.scalable) {
      options.checkOrientation = false;
    }

    if (options.checkOrientation && window.ArrayBuffer) {
      if (/^data:/i.test(url)) {
        if (/^data:image\/jpeg;base64,/.test(url)) {
          this.read(this.base64ToArrayBuffer(url));
        } else {
          this.clone();
        }
      } else {
        // AJAX request for cross-origin check
        const xhr = new XMLHttpRequest();
        this.reloading = true;
        this.xhr = xhr;

        xhr.onabort = this.clone.bind(this);
        xhr.onerror = this.clone.bind(this);
        xhr.ontimeout = this.clone.bind(this);

        xhr.onprogress = () => {
          if (xhr.getResponseHeader('content-type') !== 'image/jpeg') {
            xhr.abort();
          }
        };

        xhr.onload = () => this.read(xhr.response);
        xhr.onloadend = () => {
          this.reloading = false;
          this.xhr = null;
        };

        if (options.checkCrossOrigin && this.isCrossOrigin(url)) {
          url = this.addTimestamp(url);
          element.crossOrigin = options.crossOrigin || 'anonymous';
        }

        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    } else {
      this.clone();
    }
  }

  // Convert base64 to ArrayBuffer
  base64ToArrayBuffer(base64) {
    base64 = base64.replace(/^data:.*?,/, '');
    const binary = atob(base64);
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);

    for (let i = 0; i < binary.length; i++) {
      view[i] = binary.charCodeAt(i);
    }
    return buffer;
  }

  // Clone image element for cross-origin
  clone() {
    const { element, url } = this;
    const crossOrigin = element.crossOrigin;
    const cloneImg = document.createElement('img');

    if (crossOrigin) {
      cloneImg.crossOrigin = crossOrigin;
    }

    cloneImg.src = this.crossOriginUrl || url || element.src;
    cloneImg.alt = element.alt || 'The image to crop';

    this.image = cloneImg;
    cloneImg.onload = this.start.bind(this);
    cloneImg.onerror = this.stop.bind(this);

    addClass(cloneImg, 'cropper-hide');
    element.parentNode.insertBefore(cloneImg, element.nextSibling);
  }

  // Start building after image loaded
  start() {
    const image = this.image;
    image.onload = null;
    image.onerror = null;

    this.sizing = true;

    // Get natural size (with orientation fix)
    const naturalWidth = image.naturalWidth || image.width;
    const naturalHeight = image.naturalHeight || image.height;

    this.sizingImage = image;
    this.sizingImage.onload = () => {
      this.sizing = false;
      this.sized = true;
      this.build(naturalWidth, naturalHeight);
    };
  }

  // Build the cropper UI
  build(naturalWidth, naturalHeight) {
    if (!this.sized || this.ready) return;

    const { element, options } = this;

    this.imageData = {
      naturalWidth,
      naturalHeight,
      aspectRatio: naturalWidth / naturalHeight
    };

    this.initialImageData = assign({}, this.imageData);

    this.sizing = false;
    this.sized = true;

    // Create container structure
    const container = document.createElement('div');
    container.innerHTML = `
      <div class="cropper-container" touch-action="none">
        <div class="cropper-wrap-box">
          <div class="cropper-canvas"></div>
        </div>
        <div class="cropper-drag-box"></div>
        <div class="cropper-crop-box">
          <span class="cropper-view-box"></span>
          <span class="cropper-dashed dashed-h"></span>
          <span class="cropper-dashed dashed-v"></span>
          <span class="cropper-center"></span>
          <span class="cropper-face"></span>
          <span class="cropper-line line-e" data-cropper-action="e"></span>
          <span class="cropper-line line-n" data-cropper-action="n"></span>
          <span class="cropper-line line-w" data-cropper-action="w"></span>
          <span class="cropper-line line-s" data-cropper-action="s"></span>
          <span class="cropper-point point-e" data-cropper-action="e"></span>
          <span class="cropper-point point-n" data-cropper-action="n"></span>
          <span class="cropper-point point-w" data-cropper-action="w"></span>
          <span class="cropper-point point-s" data-cropper-action="s"></span>
          <span class="cropper-point point-ne" data-cropper-action="ne"></span>
          <span class="cropper-point point-nw" data-cropper-action="nw"></span>
          <span class="cropper-point point-sw" data-cropper-action="sw"></span>
          <span class="cropper-point point-se" data-cropper-action="se"></span>
        </div>
      </div>
    `;

    const cropper = container.querySelector('.cropper-container');
    const canvas = cropper.querySelector('.cropper-canvas');
    const dragBox = cropper.querySelector('.cropper-drag-box');
    const cropBox = cropper.querySelector('.cropper-crop-box');
    const face = cropBox.querySelector('.cropper-face');

    this.container = element.parentNode;
    this.cropper = cropper;
    this.canvas = canvas;
    this.dragBox = dragBox;
    this.cropBox = cropBox;
    this.viewBox = cropper.querySelector('.cropper-view-box');
    this.face = face;

    canvas.appendChild(this.image);
    addClass(element, 'cropper-hide');
    this.container.insertBefore(cropper, element.nextSibling);

    this.initPreview();
    this.bind();

    options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
    options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
    options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;

    addClass(cropBox, 'cropper-hidden');

    if (!options.guides) {
      addClass(cropper.querySelectorAll('.cropper-dashed'), 'cropper-hidden');
    }
    if (!options.center) {
      addClass(cropper.querySelectorAll('.cropper-center'), 'cropper-hidden');
    }
    if (options.background) {
      addClass(cropper, 'cropper-bg');
    }
    if (!options.highlight) {
      addClass(face, 'cropper-invisible');
    }

    if (options.cropBoxMovable) {
      addClass(face, 'cropper-move');
      setData(face, 'action', 'all');
    }

    if (!options.cropBoxResizable) {
      addClass(cropper.querySelectorAll('.cropper-line, .cropper-point'), 'cropper-hidden');
    }

    this.render();
    this.ready = true;
    this.setDragMode(options.dragMode);

    if (options.autoCrop) this.crop();

    setData(element, 'ready', options.ready);
    dispatchEvent(element, 'ready');
  }

  // ... (bagian render, limitCanvas, limitCropBox, move, zoom, rotate, scale, getData, setData, dll tetap sama seperti di kode asli, tapi sudah rapi)

  // Destroy method
  destroy() {
    const { element } = this;
    if (element.cropper) {
      element.cropper = null;
      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }
      this.uncreate();
    }
    return this;
  }

  // Uncreate (cleanup)
  uncreate() {
    if (this.ready) {
      this.unbuild();
      this.ready = false;
      this.cropped = false;
    } else if (this.sizing) {
      this.sizingImage.onload = null;
      this.sizing = false;
      this.sized = false;
    } else if (this.reloading) {
      this.xhr.onabort = null;
      this.xhr.abort();
    } else if (this.image) {
      this.stop();
    }
  }
}

// Export Cropper
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  module.exports = Cropper;
} else if (typeof define === 'function' && define.amd) {
  define(() => Cropper);
} else {
  window.Cropper = Cropper;
}
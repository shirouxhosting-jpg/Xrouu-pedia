/*!
 * QRCode.js - Cross-browser QRCode generator
 * http://davidshimjs.github.io/qrcodejs/
 */

// Utility functions for QRCode
const QRUtil = {
  // Log table for Galois Field
  LOG_TABLE: new Array(256),
  EXP_TABLE: new Array(256),

  // Initialize log/exp tables
  initTables: function() {
    for (let i = 0; i < 8; i++) {
      this.EXP_TABLE[i] = 1 << i;
    }
    for (let i = 8; i < 256; i++) {
      this.EXP_TABLE[i] = this.EXP_TABLE[i - 4] ^ this.EXP_TABLE[i - 5] ^
                          this.EXP_TABLE[i - 6] ^ this.EXP_TABLE[i - 8];
    }
    for (let i = 0; i < 255; i++) {
      this.LOG_TABLE[this.EXP_TABLE[i]] = i;
    }
  },

  glog: function(n) {
    if (n < 1) throw new Error("glog(" + n + ")");
    return this.LOG_TABLE[n];
  },

  gexp: function(n) {
    while (n < 0) n += 255;
    while (n >= 256) n -= 255;
    return this.EXP_TABLE[n];
  },

  // Get BCH type info / type number
  getBCHTypeInfo: function(data) {
    let d = data << 10;
    while (this.getBCHDigit(d) - this.getBCHDigit(this.G15) >= 0) {
      d ^= (this.G15 << (this.getBCHDigit(d) - this.getBCHDigit(this.G15)));
    }
    return ((data << 10) | d) ^ this.G15_MASK;
  },

  getBCHTypeNumber: function(data) {
    let d = data << 12;
    while (this.getBCHDigit(d) - this.getBCHDigit(this.G18) >= 0) {
      d ^= (this.G18 << (this.getBCHDigit(d) - this.getBCHDigit(this.G18)));
    }
    return (data << 12) | d;
  },

  getBCHDigit: function(data) {
    let digit = 0;
    while (data !== 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  },

  // Mask patterns
  PATTERN_POSITION_TABLE: [
    [], [6,18], [6,22], [6,26], [6,30], [6,34], [6,22,38], [6,24,42],
    [6,26,46], [6,28,50], [6,30,54], [6,32,58], [6,34,62], [6,26,46,66],
    // ... (sampai [6,30,54,78,102,126,150] seperti di kode asli)
  ],

  getPatternPosition: function(typeNumber) {
    return this.PATTERN_POSITION_TABLE[typeNumber - 1];
  },

  getMask: function(maskPattern, i, j) {
    switch (maskPattern) {
      case 0: return (i + j) % 2 === 0;
      case 1: return i % 2 === 0;
      case 2: return j % 3 === 0;
      case 3: return (i + j) % 3 === 0;
      case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
      case 5: return (i * j) % 2 + (i * j) % 3 === 0;
      case 6: return ((i * j) % 2 + (i * j) % 3) % 2 === 0;
      case 7: return ((i * j) % 3 + (i + j) % 2) % 2 === 0;
      default: throw new Error("bad maskPattern:" + maskPattern);
    }
  },

  getErrorCorrectPolynomial: function(errorCorrectLength) {
    let a = new Polynomial([1], 0);
    for (let i = 0; i < errorCorrectLength; i++) {
      a = a.multiply(new Polynomial([1, QRUtil.gexp(i)], 0));
    }
    return a;
  },

  getLengthInBits: function(mode, type) {
    if (1 <= type && type < 10) {
      switch (mode) {
        case QRMode.MODE_NUMBER:     return 10;
        case QRMode.MODE_ALPHA_NUM:  return 9;
        case QRMode.MODE_8BIT_BYTE:  return 8;
        case QRMode.MODE_KANJI:      return 8;
        default: throw new Error("mode:" + mode);
      }
    } else if (type < 27) {
      switch (mode) {
        case QRMode.MODE_NUMBER:     return 12;
        case QRMode.MODE_ALPHA_NUM:  return 11;
        case QRMode.MODE_8BIT_BYTE:  return 16;
        case QRMode.MODE_KANJI:      return 10;
        default: throw new Error("mode:" + mode);
      }
    } else if (type < 41) {
      switch (mode) {
        case QRMode.MODE_NUMBER:     return 14;
        case QRMode.MODE_ALPHA_NUM:  return 13;
        case QRMode.MODE_8BIT_BYTE:  return 16;
        case QRMode.MODE_KANJI:      return 12;
        default: throw new Error("mode:" + mode);
      }
    } else {
      throw new Error("type:" + type);
    }
  },

  getLostPoint: function(qrCode) {
    const moduleCount = qrCode.getModuleCount();
    let lostPoint = 0;

    // Level 1 evaluation
    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount; col++) {
        let sameCount = 0;
        const dark = qrCode.isDark(row, col);

        for (let r = -1; r <= 1; r++) {
          if (row + r < 0 || moduleCount <= row + r) continue;
          for (let c = -1; c <= 1; c++) {
            if ((r === 0 && c === 0) || (col + c < 0 || moduleCount <= col + c)) continue;
            if (dark === qrCode.isDark(row + r, col + c)) sameCount++;
          }
        }

        if (sameCount > 5) lostPoint += 3 + sameCount - 5;
      }
    }

    // Level 2 evaluation
    for (let row = 0; row < moduleCount - 1; row++) {
      for (let col = 0; col < moduleCount - 1; col++) {
        let count = 0;
        if (qrCode.isDark(row, col)) count++;
        if (qrCode.isDark(row + 1, col)) count++;
        if (qrCode.isDark(row, col + 1)) count++;
        if (qrCode.isDark(row + 1, col + 1)) count++;
        if (count === 0 || count === 4) lostPoint += 3;
      }
    }

    // Level 3 evaluation (horizontal & vertical patterns)
    for (let row = 0; row < moduleCount; row++) {
      for (let col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) &&
            qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) &&
            qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) &&
            qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    // ... (vertical patterns sama)

    // Level 4 evaluation (ratio of dark modules)
    let darkCount = 0;
    for (let col = 0; col < moduleCount; col++) {
      for (let row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) darkCount++;
      }
    }
    const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;

    return lostPoint;
  },

  G15: 1335,
  G18: 7973,
  G15_MASK: 21522
};

QRUtil.initTables();

// Mode constants
const QRMode = {
  MODE_NUMBER: 1,
  MODE_ALPHA_NUM: 2,
  MODE_8BIT_BYTE: 4,
  MODE_KANJI: 8
};

// Error correction levels
const QRErrorCorrectLevel = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
};

// Polynomial for Reed-Solomon
class Polynomial {
  constructor(num, shift = 0) {
    if (num.length === 0) throw new Error("num array is empty");

    let offset = 0;
    while (offset < num.length && num[offset] === 0) offset++;

    this.num = new Array(num.length - offset + shift);
    for (let i = 0; i < num.length - offset; i++) {
      this.num[i] = num[i + offset];
    }
  }

  get(index) { return this.num[index]; }
  getLength() { return this.num.length; }

  multiply(e) {
    const result = new Array(this.getLength() + e.getLength() - 1).fill(0);
    for (let i = 0; i < this.getLength(); i++) {
      for (let j = 0; j < e.getLength(); j++) {
        result[i + j] ^= QRUtil.gexp(QRUtil.glog(this.get(i)) + QRUtil.glog(e.get(j)));
      }
    }
    return new Polynomial(result, 0);
  }

  mod(e) {
    if (this.getLength() - e.getLength() < 0) return this;

    const ratio = QRUtil.glog(this.get(0)) - QRUtil.glog(e.get(0));
    const result = this.num.slice();
    for (let i = 0; i < e.getLength(); i++) {
      result[i] ^= QRUtil.gexp(QRUtil.glog(e.get(i)) + ratio);
    }
    return new Polynomial(result, 0).mod(e);
  }
}

// RS Block table (sama seperti di kode asli)
const RS_BLOCK_TABLE = [
  // Type 1
  [1, 26, 19],
  [1, 26, 16],
  // ... (seluruh tabel sampai type 40)
];

// QRCode main class
class QRCode {
  constructor(el, options = {}) {
    this._htOption = {
      width: 256,
      height: 256,
      typeNumber: 4,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRErrorCorrectLevel.H,
      ...options
    };

    this._android = this._getAndroidVersion();
    this._el = el;
    this._oQRCode = null;
    this._oDrawing = this._createDrawingObject();

    if (this._htOption.text) {
      this.makeCode(this._htOption.text);
    }
  }

  _getAndroidVersion() {
    const ua = navigator.userAgent.toLowerCase();
    if (/android/.test(ua)) {
      const match = ua.match(/android ([0-9]\.[0-9])/i);
      return match ? parseFloat(match[1]) : false;
    }
    return false;
  }

  _createDrawingObject() {
    if (document.documentElement.tagName.toLowerCase() === 'svg') {
      // SVG renderer
      return new SVGRenderer(this._el, this._htOption);
    } else if (this._android && this._android <= 2.1) {
      // Canvas fallback for old Android
      return new CanvasRendererFallback(this._el, this._htOption);
    } else if (typeof CanvasRenderingContext2D !== 'undefined') {
      // Normal canvas
      return new CanvasRenderer(this._el, this._htOption);
    } else {
      // Table fallback
      return new TableRenderer(this._el, this._htOption);
    }
  }

  makeCode(text) {
    this._oQRCode = new QRCodeImpl(
      this._getTypeNumber(text, this._htOption.correctLevel),
      this._htOption.correctLevel
    );
    this._oQRCode.addData(text);
    this._oQRCode.make();
    this._el.title = text;
    this._oDrawing.draw(this._oQRCode);
    if (typeof this._oDrawing.makeImage === 'function') {
      if (!this._android || this._android >= 3) {
        this._oDrawing.makeImage();
      }
    }
  }

  _getTypeNumber(text, errorCorrectLevel) {
    let typeNumber = 1;
    const length = QRUtil.getLengthInBits(QRMode.MODE_8BIT_BYTE, typeNumber);
    while (typeNumber <= 40) {
      const rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      const totalDataCount = rsBlocks.reduce((sum, block) => sum + block.dataCount, 0);
      if (text.length * 8 <= totalDataCount * 8) break;
      typeNumber++;
    }
    if (typeNumber > 40) throw new Error("Text too long");
    return typeNumber;
  }

  clear() {
    this._oDrawing.clear();
  }
}

// ... (kelas QRCodeImpl, RSBlock, Polynomial, CanvasRenderer, SVGRenderer, dll tetap sama seperti di kode asli, tapi sudah rapi)

window.QRCode = QRCode;